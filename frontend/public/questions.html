<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="questions.css">
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:200,300,400,600' rel='stylesheet' type='text/css'>
</head>
<body>
<script src="//cdnjs.cloudflare.com/ajax/libs/hammer.js/1.1.3/hammer.min.js"></script>
<script src="http://code.jquery.com/mobile/1.4.4/jquery.mobile-1.4.4.min.js"></script>

<script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
<div id="wrap"></div>

<script>
var NUM_ITEMS = 6;

$(function() {
  
  // Cache some selectors
  var $wrap = $('#wrap'),
      $output = $('#output'),
      $list = $('<ul/>').appendTo($wrap);
  
  // Create some list items
  for(var i = 0; i < NUM_ITEMS; i++) {
    $list.append('<li data-cid="' + i + '"><a href="#">question ' + (i+1) + '</a></li>');
  }
  
  // Cache a reference to the collection of list items
  var $items = $list.find('li');
  
  // Make the items equal heights
  var sizeItems = function() {
    var ih = Math.floor($(window).height() / $items.length);
    $items.height(ih).find('a').css('line-height',ih + 'px');
  }
  // Ensure the items handle screen reszing
  $(window).on('resize', sizeItems).trigger('resize');
 
  
  /** 
   * Set up a swipe gesture.  Hammer has a 'swipe' event but
   * it's not particularly reliable in my experience, so I fake it
   * by detecting drags and deciding if it was a swipe based on the distance.
   *
   * Note that this just takes distance into account - you could do a slow drag 
   * and it would still get picked up as a 'swipe' using this method. You would
   * need to get time deltas between the drag start and end if you wanted to check
   * the speed of the drag as well.
  **/
  
  var self = this;
  
  // We're going to bind the drag event listener to the list container. Hammer doesn't
  // understand jQuery collections so we need to use the raw DOM element reference.
  var listContainer = $list[0];
  
  // Events will bubble up the DOM and fire on all the elements we drag over, but
  // we only want to react to the event if the user performs it inside a list item.
  // This var stores a reference to selector we'll be checking for.
  var targetSelector = 'ul li';
  
  // To prevent errant taps/clicks being interpreted as drags, we only want to
  // react to drags of 100px or more.
  var threshold = 100;
  
  // Now we bind the event to the list container.
  Hammer(listContainer).on('drag', function(e) {
    
    // Some vars we will use later to see if we dragged the right element
    var isDraggingTarget = false,
        isDraggingChildOfTarget = false,
        draggedParents = false;
    
    // Get the element on which the 'drag' event has just fired
    // and wrap it in a jQuery object for convenience
    var dragged = $(e.target);
     
    // Check to see if we dragged the element we want directly
    isDraggingTarget = dragged.is(targetSelector);
    
    // If we havent' dragged the element we want, we might be dragging
    // one of its children (e.g. a <span> inside an <li>), so check that
    // the element doesn't have a parent in the DOM which matches what we
    // want
    if(!isDraggingTarget) {
      draggedParents = dragged.parents(targetSelector);
      isDraggingChildOfTarget = draggedParents.length;
    }
    
    // If we're dragging our target or one of its children, we want to proceed
    if(isDraggingTarget || isDraggingChildOfTarget) {
      
      // Events bubble up the DOM so we need to stop this, as we already know
      // what we need to know
      e.stopPropagation();
      
      // Drag/swipe events have side-effects on some OSes e.g. task switching etc,
      // so we want to kill that behaviour here
      e.preventDefault();
      e.gesture.preventDefault();

      // We want to work just our target element - that's either the one we dragged
      // directly, or the parent we discovered was actually the target.
      var el = (isDraggingChildOfTarget) ? draggedParents : dragged;
      
      // Check the distance of the drag/swipe, on the X-axis only.
      // If the drag was to the left, it will be a negative value
      var dragDistance = e.gesture.deltaX;

      // If the drag distance exceeds our set threshold, we'll interpret it as a
      // swipe, and act accordingly depending on what direction it was done in.
      // We apply a CSS transition class to make the item look like it was moved
      // in response to a swipe.
      if(dragDistance > threshold) {
        
        el.removeClass('prompt-remove');
        
      } else if (dragDistance < -threshold) {
        
        el.addClass('prompt-remove');
        
      }
      
      // You could also update the position of the item here, so it looks like you're
      // dragging in real time, but that can be a performance hit if you're not
      // careful.
    }
    
    // If we're not dragging our target or one of its children, we do nothing.
    // The event will fire off unmolested and continue to bubble up the DOM, firing
    // the above code on every parent element of the element we dragged.
    
  });
  
});
</script>
</body>
</html>

