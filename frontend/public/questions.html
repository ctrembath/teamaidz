<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="questions.css">
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:200,300,400,600' rel='stylesheet' type='text/css'>
</head>
<body>
<script src="//cdnjs.cloudflare.com/ajax/libs/hammer.js/1.1.3/hammer.min.js"></script>
<script src="http://code.jquery.com/mobile/1.4.4/jquery.mobile-1.4.4.min.js"></script>

<script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>

<header>

  <h1>W O U L D - Y O U - R A T H E R ..</h1>
</header>
<div id="wrap"></div>

<script>
var NUM_ITEMS = 6;

$(function() {
  
  // Cache some selectors
  var $wrap = $('#wrap'),
      $output = $('#output'),
      $list = $('<ul/>').appendTo($wrap);
  
  // Create some list items
  for(var i = 0; i < NUM_ITEMS; i++) {
    $list.append('<li data-cid="' + i + '"><a href="#">question ' + (i+1) + '</a></li>');
  }
  
  // Cache a reference to the collection of list items
  var $items = $list.find('li');
  
  // Make the items equal heights
  var sizeItems = function() {
    var ih = Math.floor($(window).height() / $items.length);
    $items.height(ih).find('a').css('line-height',ih + 'px');
  }
  // Ensure the items handle screen reszing
  $(window).on('resize', sizeItems).trigger('resize');
 

  
  var self = this;
  
  var listContainer = $list[0];
  
  var targetSelector = 'ul li';

  var threshold = 100;

  Hammer(listContainer).on('drag', function(e) {
    
    var isDraggingTarget = false,
        isDraggingChildOfTarget = false,
        draggedParents = false;
    
    var dragged = $(e.target);
     

    isDraggingTarget = dragged.is(targetSelector);
    
    // If we havent' dragged the element we want, we might be dragging
    // one of its children (e.g. a <span> inside an <li>), so check that
    // the element doesn't have a parent in the DOM which matches what we
    // want
    if(!isDraggingTarget) {
      draggedParents = dragged.parents(targetSelector);
      isDraggingChildOfTarget = draggedParents.length;
    }
    
    // If we're dragging our target or one of its children, we want to proceed
    if(isDraggingTarget || isDraggingChildOfTarget) {
      
      // Events bubble up the DOM so we need to stop this, as we already know
      // // what we need to know
      // e.stopPropagation();
      
      // Drag/swipe events have side-effects on some OSes e.g. task switching etc,
      // so we want to kill that behaviour here
      // e.preventDefault();
      // e.gesture.preventDefault();

      // We want to work just our target element - that's either the one we dragged
      // directly, or the parent we discovered was actually the target.
      var el = (isDraggingChildOfTarget) ? draggedParents : dragged;
      
      // Check the distance of the drag/swipe, on the X-axis only.
      // If the drag was to the left, it will be a negative value
      var dragDistance = e.gesture.deltaX;

      // If the drag distance exceeds our set threshold, we'll interpret it as a
      // swipe, and act accordingly depending on what direction it was done in.
      // We apply a CSS transition class to make the item look like it was moved
      // in response to a swipe.
      if(dragDistance > threshold) {
        
        el.removeClass('prompt-remove');
        
      } else if (dragDistance < -threshold) {
        
        el.addClass('prompt-remove');
        
      }
      
      // You could also update the position of the item here, so it looks like you're
      // dragging in real time, but that can be a performance hit if you're not
      // careful.
    }
    
    // If we're not dragging our target or one of its children, we do nothing.
    // The event will fire off unmolested and continue to bubble up the DOM, firing
    // the above code on every parent element of the element we dragged.
    
  });
  
});
</script>
</body>
</html>

